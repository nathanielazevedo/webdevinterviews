import React from "react";
import { Box, Grid, Container, Button, Typography } from "@mui/material";
import {
  BattleControls,
  BattleResults,
  ResizableCodingPanels,
  MultiplayerLeaderboard,
  BattleEntrySideNav,
} from "./components";
import { useBattleEnhanced } from "../../hooks/battle";

// Import types from the battle hooks
import type { Player, BattleState } from "../../hooks/battle";

const BattleMain: React.FC = () => {
  // Use the new enhanced battle hook
  const {
    // IDs
    battleId,
    currentPlayerId,
    currentPlayerName,
    
    // Battle State
    battleState,
    isAdmin,
    error,
    loading,
    
    // Players
    players,
    playerResults,
    
    // Questions
    currentQuestion,
    questionPool,
    questionLoading,
    
    // Timer
    timeUntilStart,
    battleStartTime,
    effectiveCountdown,
    formatTime,
    
    // Actions
    handleStartBattle,
    handleResetBattle,
    handleSubmitSolution,
    handleTestResults,
    handleCreateScheduledBattle,
    getCurrentQuestion,
    getQuestionPool,
    getBattleInfo,
    
    // Connection
    isConnected,
  } = useBattleEnhanced();

  // Original broken useEffect - need to clean up
  useEffect(() => {
    const timer = setTimeout(() => {
      console.log(
        "ðŸ“š Battle page loaded - battle info should be fetched automatically via useBattle hook"
      );
      // Battle info and question pool will be fetched automatically when WebSocket connects

      ws.onopen = () => {
        console.log("ï¿½ Test WebSocket connected for auto-battle creation");

        // Join room first
        ws.send(
          JSON.stringify({
            type: "join",
            roomId: battleId,
            userId: currentPlayerId,
          })
        );

        setTimeout(() => {
          console.log("ðŸ“¤ Auto-sending create-battle:", scheduledTime);
          ws.send(
            JSON.stringify({
              type: "create-battle",
              scheduledStartTime: scheduledTime,
              durationMinutes: 15,
            })
          );
        }, 500);

        setTimeout(() => {
          console.log("ï¿½ Auto-sending get-battle-info");
          ws.send(
            JSON.stringify({
              type: "get-battle-info",
            })
          );
        }, 1000);

        setTimeout(() => ws.close(), 2000);
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        console.log("ðŸ“¨ Auto-test response:", data);

        if (data.type === "battle-created" && data.scheduledStartTime) {
          console.log(
            "âœ… Battle created successfully! Scheduled for:",
            data.scheduledStartTime
          );
          // TODO: Update the UI with the real scheduled time
        }

        if (data.type === "battle-info" && data.battle?.scheduledStartTime) {
          console.log(
            "âœ… Battle info received! Scheduled for:",
            data.battle.scheduledStartTime
          );
          // TODO: Update countdown to use real time
        }
      };

      ws.onerror = (error) => {
        console.error("âŒ Auto-test WebSocket error:", error);
      };
    }, 3000); // Auto-create after 3 seconds

    return () => clearTimeout(timer);
  }, [battleId, currentPlayerId]); // Only run once when component mounts

  // Use WebSocket countdown or fallback to manual countdown
  const [countdown, setCountdown] = useState<number | null>(null);
  const effectiveCountdown =
    timeUntilStart !== null ? timeUntilStart : countdown;

  // Timer logic for active battle
  useEffect(() => {
    let interval: NodeJS.Timeout;

    if (battleState.status === "active" && battleState.timeRemaining > 0) {
      interval = setInterval(() => {
        setBattleState((prev) => ({
          ...prev,
          timeRemaining: prev.timeRemaining - 1,
        }));
      }, 1000);
    }

    return () => clearInterval(interval);
  }, [battleState.status, battleState.timeRemaining]);

  // Manual countdown logic (fallback for local testing)
  useEffect(() => {
    let interval: NodeJS.Timeout;

    if (countdown !== null && countdown > 0 && timeUntilStart === null) {
      interval = setInterval(() => {
        setCountdown((prev) => (prev ? prev - 1 : 0));
      }, 1000);
    } else if (countdown === 0 && timeUntilStart === null) {
      setBattleState((prev) => ({ ...prev, status: "active" }));
      setCountdown(null);
    }

    return () => clearInterval(interval);
  }, [countdown, timeUntilStart]);

  // Handle automatic battle start from WebSocket
  useEffect(() => {
    if (serverBattleStatus === "active" && battleState.status !== "active") {
      console.log("ðŸš€ Battle started automatically from server");
      setBattleState((prev) => ({ ...prev, status: "active" }));
      setCountdown(null);
    }
  }, [serverBattleStatus, battleState.status]);

  // Fetch current question when component mounts or battle becomes active
  useEffect(() => {
    if (
      battleState.status === "active" &&
      !currentQuestion &&
      !questionLoading
    ) {
      console.log("ðŸ” Fetching current question for active battle");
      getCurrentQuestion();
    }
  }, [
    battleState.status,
    currentQuestion,
    questionLoading,
    getCurrentQuestion,
  ]);

  // Update battle state with question information
  useEffect(() => {
    if (currentQuestion) {
      setBattleState((prev) => ({
        ...prev,
        currentProblem: currentQuestion.title,
      }));
      console.log("â“ Updated battle with question:", currentQuestion.title);
    }
  }, [currentQuestion]);

  const handleStartBattle = () => {
    if (isAdmin) {
      // Admin starts battle via server - this may set a scheduled start time
      startServerBattle();
      console.log("ðŸŽ® Admin requested battle start");
    } else {
      // Regular user can only request battle start (fallback for testing)
      setBattleState((prev) => ({ ...prev, status: "countdown" }));
      setCountdown(3);
      console.log("ðŸŽ® Local battle start (testing mode)");
    }
  };

  const handleCreateScheduledBattle = () => {
    // Create a battle scheduled to start in 30 seconds
    const scheduledTime = new Date(Date.now() + 30 * 1000).toISOString();
    const durationMinutes = 15; // 15 minute battle

    console.log("âš”ï¸ handleCreateScheduledBattle called");
    console.log("âš”ï¸ scheduledTime:", scheduledTime);
    console.log("âš”ï¸ createBattle function:", typeof createBattle);

    if (createBattle) {
      console.log("ðŸ“¤ Calling createBattle with:", {
        scheduledTime,
        durationMinutes,
      });
      createBattle(scheduledTime, durationMinutes);
    } else {
      console.error("âŒ createBattle function not available");
    }

    setBattleState((prev) => ({ ...prev, status: "countdown" }));
  };

  const handleResetBattle = () => {
    setBattleState({
      status: "waiting",
      timeRemaining: 900,
      totalTime: 900,
      currentProblem: "Two Sum",
      winners: [],
      totalPlayers: players.length,
      completedPlayers: 0,
    });
    setCountdown(null);

    // Reset all players' test progress
    setPlayers((prev) =>
      prev.map((player) => ({
        ...player,
        testProgress: undefined,
        status: "ready",
      }))
    );
  };

  const handleSubmitSolution = (code?: string) => {
    // Implement solution submission logic
    console.log("Submitting solution:", code);
    setBattleState((prev) => ({
      ...prev,
      status: "finished",
      winner: players[Math.floor(Math.random() * 2)].name,
    }));
  };

  const handleTestResults = (results: { testCases: { passed: boolean }[] }) => {
    // Send test results to WebSocket server for multiplayer sync
    if (results && results.testCases) {
      const passed = results.testCases.filter((tc) => tc.passed).length;
      const total = results.testCases.length;

      // Send to WebSocket - this will trigger updates for all players
      sendTestResults(passed, total);

      console.log("Sent test results to WebSocket:", { passed, total });
    }
    console.log("Testing code results:", results);
  };

  const handleTestCode = () => {
    // Implement code testing logic for BattleControls
    console.log("Test code button clicked");
  };

  return (
    <>
      <Container maxWidth="xl">
        <Box sx={{ py: 4 }}>
          {/* <BattleHeader /> */}
          {/* <BattleStatusPanel battleState={battleState} countdown={countdown} /> */}
          {/* Pre-battle and post-battle layout */}
          {(battleState.status === "waiting" ||
            battleState.status === "countdown") && (
            <Grid container spacing={3}>
              {/* Side Navigation */}
              <Grid item xs={12} md={3}>
                <BattleEntrySideNav
                  players={players}
                  currentUserId={currentPlayerId}
                />
              </Grid>

              {/* Main Content */}
              <Grid item xs={12} md={9}>
                <MultiplayerLeaderboard
                  players={players}
                  currentUserId={currentPlayerId}
                  battleStatus={battleState.status}
                  playerResults={playerResults}
                  countdown={effectiveCountdown}
                  battleStartTime={battleStartTime}
                />

                {/* Debug: Question fetching and battle timing buttons */}
                <Box sx={{ mt: 2, display: "flex", gap: 2, flexWrap: "wrap" }}>
                  <Button
                    variant="outlined"
                    onClick={getCurrentQuestion}
                    disabled={questionLoading}
                  >
                    {questionLoading ? "Loading..." : "Get Current Question"}
                  </Button>
                  <Button
                    variant="outlined"
                    onClick={getQuestionPool}
                    disabled={questionLoading}
                  >
                    {questionLoading ? "Loading..." : "Get Question Pool"}
                  </Button>
                  <Button
                    variant="contained"
                    color="primary"
                    onClick={handleCreateScheduledBattle}
                    disabled={
                      serverBattleStatus === "active" ||
                      battleStartTime !== null
                    }
                  >
                    Create Scheduled Battle (30s)
                  </Button>
                  <Button variant="outlined" onClick={getBattleInfo}>
                    Get Battle Info
                  </Button>
                  <Button
                    variant="outlined"
                    color="secondary"
                    onClick={() => {
                      console.log("ðŸ§ª Testing direct WebSocket call");
                      // Direct WebSocket test - bypass the hook
                      const ws = new WebSocket(`ws://localhost:3001`);
                      ws.onopen = () => {
                        console.log("ðŸ”Œ Direct WS connected");
                        // Join room first
                        ws.send(
                          JSON.stringify({
                            type: "join",
                            roomId: "battle_1",
                            userId: currentPlayerId,
                          })
                        );

                        setTimeout(() => {
                          console.log(
                            "ðŸ“¤ Sending get-battle-info via direct WS"
                          );
                          ws.send(
                            JSON.stringify({
                              type: "get-battle-info",
                            })
                          );
                        }, 500);

                        setTimeout(() => {
                          const scheduledTime = new Date(
                            Date.now() + 30 * 1000
                          ).toISOString();
                          console.log(
                            "ðŸ“¤ Sending create-battle via direct WS",
                            scheduledTime
                          );
                          ws.send(
                            JSON.stringify({
                              type: "create-battle",
                              scheduledStartTime: scheduledTime,
                              durationMinutes: 15,
                            })
                          );
                        }, 1000);

                        setTimeout(() => ws.close(), 3000);
                      };

                      ws.onmessage = (event) => {
                        console.log(
                          "ðŸ“¨ Direct WS response:",
                          JSON.parse(event.data)
                        );
                      };
                    }}
                  >
                    Direct WS Test
                  </Button>
                  {currentQuestion && (
                    <Typography variant="body2" sx={{ alignSelf: "center" }}>
                      Current: <strong>{currentQuestion.title}</strong> (
                      {currentQuestion.difficulty})
                    </Typography>
                  )}
                  {questionPool.length > 0 && (
                    <Typography variant="body2" sx={{ alignSelf: "center" }}>
                      Pool: {questionPool.length} questions
                    </Typography>
                  )}
                  {battleStartTime && (
                    <Typography
                      variant="body2"
                      sx={{ alignSelf: "center", color: "primary.main" }}
                    >
                      Battle starts:{" "}
                      <strong>
                        {new Date(battleStartTime).toLocaleTimeString()}
                      </strong>
                    </Typography>
                  )}
                  {timeUntilStart !== null && timeUntilStart > 0 && (
                    <Typography
                      variant="body2"
                      sx={{ alignSelf: "center", color: "secondary.main" }}
                    >
                      Countdown:{" "}
                      <strong>
                        {Math.floor(timeUntilStart / 60)}:
                        {(timeUntilStart % 60).toString().padStart(2, "0")}
                      </strong>
                    </Typography>
                  )}
                </Box>

                {!isAdmin && (
                  <BattleControls
                    battleStatus={battleState.status}
                    onStartBattle={handleStartBattle}
                    onResetBattle={handleResetBattle}
                    onSubmitSolution={handleSubmitSolution}
                    onTestCode={handleTestCode}
                  />
                )}
              </Grid>
            </Grid>
          )}
          {/* Active battle layout with editor */}
          {(battleState.status === "active" ||
            battleState.status === "finished") && (
            <Box
              sx={{
                position: "fixed",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                display: "flex",
                flexDirection: "column",
                backgroundColor: "background.default",
                overflow: "hidden",
                zIndex: 1000,
              }}
            >
              {/* Fixed-height coding panels */}
              <Box sx={{ flexGrow: 1, minHeight: 0 }}>
                <ResizableCodingPanels
                  problemTitle={
                    currentQuestion?.title || battleState.currentProblem
                  }
                  problemId={currentQuestion?.slug || "twoSum"}
                  onSubmit={handleSubmitSolution}
                  onTest={handleTestResults}
                  battleId={battleId}
                  playerId={currentPlayerId}
                  players={players}
                  currentUserId={currentPlayerId}
                />
              </Box>
            </Box>
          )}
          <BattleResults
            winners={battleState.winners}
            isVisible={battleState.status === "finished"}
          />
        </Box>
      </Container>
    </>
  );
};

export default BattleMain;
